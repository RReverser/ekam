#! /bin/sh

set -eu

if test $# = 0; then
  # Ekam is querying the script.  Tell it that we like C++ source files.
  echo trigger filetype:.cpp
  echo trigger filetype:.cc
  echo trigger filetype:.C
  exit 0
fi

INPUT=$1

BASENAME_EXT=`basename $INPUT`
BASENAME=`basename $INPUT .cpp`

echo findProvider special:ekam-interceptor
read INTERCEPTOR

if test "$INTERCEPTOR" = ""; then
  echo "error:  couldn't find intercept.so." >&2
  exit 1
fi

# Ask Ekam where to put the output file.  Actually, the compiler will make the same request again
# when it runs, but we need to know the location too.
echo newOutput ${BASENAME}.o
read OUTPUT

# Compile!  We LD_PRELOAD intercept.so to intercept open() and other filesystem calls and convert
# them into Ekam requests.  intercept.so expects file descriptors 3 and 4 to be the Ekam request
# and response streams, so we remap them to stdout and stdin, respectively.  We also remap stdout
# itself to stderr just to make sure that if the compiler prints anything to stdout (which normally
# it shouldn't), that does not get misinterpreted as an Ekam request.
CXX=${CXX:-c++}
CXXFLAGS=${CXXFLAGS:-}
LD_PRELOAD=$INTERCEPTOR $CXX $CXXFLAGS -I/ekam-provider/c++header \
    -c $BASENAME_EXT -o ${BASENAME}.o 3>&1 4<&0 >&2

# Ask Ekam where to put the symbol and deps lists.
echo newOutput ${BASENAME}.o.syms
read SYMFILE
echo newOutput ${BASENAME}.o.deps
read DEPFILE

# Generate the symbol list.
# TODO:  Would be nice to use nm -C here to demangle names but it doesn't appear
#   to be supported on OSX.
nm $OUTPUT > $SYMFILE

# Function which reads the symbol list on stdin and writes all symbols matching
# the given type pattern to stdout, optionally with a prefix.
readsyms() {
  grep '[^ ]*  *['$1'] ' | sed -e 's,^[^ ]*  *. \(.*\)$,'"${2:-}"'\1,g'
}

# Construct the deps file by listing all undefined symbols.
readsyms U < $SYMFILE > $DEPFILE

# Tell Ekam about the symbols provided by this file.
readsyms ABCDGRSTV "provide $OUTPUT c++symbol:" < $SYMFILE
